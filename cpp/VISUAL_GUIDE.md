# 稀疏矩阵算法图解

## 一、三元组顺序表（数组实现）

### 数据结构示意图
```
原矩阵 (5×6):
     0   1   2   3   4   5
   +---+---+---+---+---+---+
0  | 0 | 2 | 0 | 0 | 3 | 0 |
   +---+---+---+---+---+---+
1  | 0 | 0 | 4 | 0 | 0 | 0 |
   +---+---+---+---+---+---+
2  | 5 | 0 | 0 | 6 | 0 | 0 |
   +---+---+---+---+---+---+
3  | 0 | 7 | 0 | 0 | 0 | 8 |
   +---+---+---+---+---+---+
4  | 0 | 0 | 0 | 9 | 0 | 0 |
   +---+---+---+---+---+---+

三元组数组表示:
  index |  row  |  col  | value
  ------+-------+-------+-------
    0   |   0   |   1   |   2
    1   |   0   |   4   |   3
    2   |   1   |   2   |   4
    3   |   2   |   0   |   5
    4   |   2   |   3   |   6
    5   |   3   |   1   |   7
    6   |   3   |   5   |   8
    7   |   4   |   3   |   9
```

### 快速转置算法步骤演示

#### 步骤1：统计每列非零元素个数
```
列号:    0   1   2   3   4   5
num[]:   1   2   1   2   1   1
          ↑   ↑   ↑   ↑   ↑   ↑
        col0 col1 col2 col3 col4 col5
```

#### 步骤2：计算每列在转置后的起始位置
```
cpot[0] = 0
cpot[1] = cpot[0] + num[0] = 0 + 1 = 1
cpot[2] = cpot[1] + num[1] = 1 + 2 = 3
cpot[3] = cpot[2] + num[2] = 3 + 1 = 4
cpot[4] = cpot[3] + num[3] = 4 + 2 = 6
cpot[5] = cpot[4] + num[4] = 6 + 1 = 7

结果:
列号:     0   1   2   3   4   5
cpot[]:   0   1   3   4   6   7
```

#### 步骤3：按顺序转置每个元素
```
原三元组 → 转置位置计算 → 转置后三元组

(0,1,2) → col=1, pos=cpot[1]=1 → T[1]=(1,0,2), cpot[1]=2
(0,4,3) → col=4, pos=cpot[4]=6 → T[6]=(4,0,3), cpot[4]=7
(1,2,4) → col=2, pos=cpot[2]=3 → T[3]=(2,1,4), cpot[2]=4
(2,0,5) → col=0, pos=cpot[0]=0 → T[0]=(0,2,5), cpot[0]=1
(2,3,6) → col=3, pos=cpot[3]=4 → T[4]=(3,2,6), cpot[3]=5
(3,1,7) → col=1, pos=cpot[1]=2 → T[2]=(1,3,7), cpot[1]=3
(3,5,8) → col=5, pos=cpot[5]=7 → T[7]=(5,3,8), cpot[5]=8
(4,3,9) → col=3, pos=cpot[3]=5 → T[5]=(3,4,9), cpot[3]=6
```

#### 转置结果
```
转置后矩阵 (6×5):
     0   1   2   3   4
   +---+---+---+---+---+
0  | 0 | 0 | 5 | 0 | 0 |
   +---+---+---+---+---+
1  | 2 | 0 | 0 | 7 | 0 |
   +---+---+---+---+---+
2  | 0 | 4 | 0 | 0 | 0 |
   +---+---+---+---+---+
3  | 0 | 0 | 6 | 0 | 9 |
   +---+---+---+---+---+
4  | 3 | 0 | 0 | 0 | 0 |
   +---+---+---+---+---+
5  | 0 | 0 | 0 | 8 | 0 |
   +---+---+---+---+---+

转置后三元组数组:
  index |  row  |  col  | value
  ------+-------+-------+-------
    0   |   0   |   2   |   5
    1   |   1   |   0   |   2
    2   |   1   |   3   |   7
    3   |   2   |   1   |   4
    4   |   3   |   2   |   6
    5   |   3   |   4   |   9
    6   |   4   |   0   |   3
    7   |   5   |   3   |   8
```

---

## 二、十字链表（广义表实现）

### 完整结构图
```
        colHead数组
         [0] [1] [2] [3] [4] [5]
          ↓   ↓   ↓   ↓   ↓   ↓
rowHead
[0] →  (0,1,2)→→→→→→→→→(0,4,3)
        ↓down    right↑   ↓
[1]     │       (1,2,4)   │
        ↓         ↓       │
[2]  (2,0,5)→→→(2,3,6)    │
        ↓         ↓       │
[3]  │ (3,1,7)→→→│→→→→→→(3,5,8)
        ↓         ↓
[4]     │       (4,3,9)
        ↓         ↓
       null      null
```

### 详细节点结构
```
每个节点包含5个域:
┌─────────┬─────────┬────────┬────────┬────────┐
│   row   │   col   │ value  │ right  │  down  │
└─────────┴─────────┴────────┴────────┴────────┘
   行号      列号      元素值    右指针   下指针
```

### 节点连接示例
```
节点 (0,1,2):
┌───┬───┬───┬────────┬────────┐
│ 0 │ 1 │ 2 │  →(0,4,3) │ →(3,1,7) │
└───┴───┴───┴────────┴────────┘
  ↑   ↑   ↑      ↑         ↑
  行  列  值   同行下个   同列下个
```

### 遍历方式

#### 1. 按行遍历（沿right指针）
```
第0行: rowHead[0] → (0,1,2) → (0,4,3) → null
第1行: rowHead[1] → (1,2,4) → null
第2行: rowHead[2] → (2,0,5) → (2,3,6) → null
第3行: rowHead[3] → (3,1,7) → (3,5,8) → null
第4行: rowHead[4] → (4,3,9) → null
```

#### 2. 按列遍历（沿down指针）
```
第0列: colHead[0] → (2,0,5) → null
第1列: colHead[1] → (0,1,2) → (3,1,7) → null
第2列: colHead[2] → (1,2,4) → null
第3列: colHead[3] → (2,3,6) → (4,3,9) → null
第4列: colHead[4] → (0,4,3) → null
第5列: colHead[5] → (3,5,8) → null
```

### 插入元素过程

#### 插入 (1,2,4) 到空矩阵:

**步骤1：创建新节点**
```
newNode = (1, 2, 4)
```

**步骤2：插入到行链表**
```
rowHead[1] == null
→ newNode.right = rowHead[1] (null)
→ rowHead[1] = newNode

结果:
rowHead[1] → (1,2,4) → null
```

**步骤3：插入到列链表**
```
colHead[2] == null
→ newNode.down = colHead[2] (null)
→ colHead[2] = newNode

结果:
colHead[2] → (1,2,4) → null
```

#### 插入 (3,1,7) 到已有元素的矩阵:

**假设已有 (0,1,2):**
```
前状态:
rowHead[0] → (0,1,2) → null
colHead[1] → (0,1,2) → null
```

**插入 (3,1,7):**
```
步骤1: 插入到行链表
rowHead[3] == null
→ rowHead[3] = (3,1,7)

步骤2: 插入到列链表
colHead[1] → (0,1,2) (已存在)
比较: (3,1,7).row > (0,1,2).row
→ 插入到 (0,1,2) 之后

结果:
rowHead[3] → (3,1,7) → null
colHead[1] → (0,1,2) → (3,1,7) → null
            (down连接)
```

---

## 三、性能对比实测数据

### 测试环境
- 矩阵规模: 1000×1000
- 非零元素: 1000个
- 稀疏度: 99.9%

### 空间占用
```
三元组顺序表:
  - 数组大小: 1000 × 12 bytes = 12 KB
  - 附加信息: 12 bytes
  - 总计: ~12 KB

十字链表:
  - 节点数: 1000个
  - 每节点: 20 bytes (含指针)
  - 头指针数组: 2000 × 8 = 16 KB
  - 总计: ~36 KB
```

### 时间复杂度对比
```
操作          三元组      十字链表
创建         O(n log n)   O(n·k)
快速转置     O(m+n)       O(m)
访问元素     O(m)         O(k)
插入元素     O(m)         O(k)

其中: m=非零元素数, n=列数, k=平均行/列长度
```

---

## 四、适用场景建议

### 三元组顺序表适合:
✓ 矩阵较稳定，很少修改
✓ 需要频繁进行转置操作
✓ 对空间要求严格
✓ 按行序依次访问

### 十字链表适合:
✓ 需要频繁插入删除元素
✓ 需要进行矩阵加法、乘法运算
✓ 需要同时按行和按列遍历
✓ 对灵活性要求高

---

## 五、常见应用场景

1. **科学计算**: 大规模线性方程组求解
2. **图像处理**: 稀疏图像表示与压缩
3. **网络分析**: 社交网络、Web图的邻接矩阵
4. **推荐系统**: 用户-商品评分矩阵
5. **自然语言处理**: 文档-词项矩阵
6. **有限元分析**: 大型结构刚度矩阵

---

这份图解应该能帮你更好地理解两种实现方式！
