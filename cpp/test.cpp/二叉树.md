## ğŸŒ³ ä¸€ã€äºŒå‰æ ‘çš„åŸºæœ¬æ¦‚å¿µ

- **äºŒå‰æ ‘**æ˜¯ä¸€ç§æ¯ä¸ªç»“ç‚¹æœ€å¤šæœ‰ä¸¤ä¸ªå­ç»“ç‚¹çš„æ ‘å½¢ç»“æ„ã€‚
- é€šå¸¸åŒ…æ‹¬ï¼š
  - **å·¦å­æ ‘ï¼ˆLeft Subtreeï¼‰**
  - **å³å­æ ‘ï¼ˆRight Subtreeï¼‰**
- ç‰¹æ®Šç±»å‹ï¼š
  - æ»¡äºŒå‰æ ‘ï¼ˆFull Binary Treeï¼‰
  - å®Œå…¨äºŒå‰æ ‘ï¼ˆComplete Binary Treeï¼‰
  - äºŒå‰æœç´¢æ ‘ï¼ˆBST, Binary Search Treeï¼‰

------

## âš™ï¸ äºŒã€äºŒå‰æ ‘çš„åŸºæœ¬æ“ä½œ

| æ“ä½œ                | è¯´æ˜                                      | æ—¶é—´å¤æ‚åº¦      |
| ------------------- | ----------------------------------------- | --------------- |
| åˆ›å»ºï¼ˆCreateï¼‰      | æ„å»ºä¸€æ£µäºŒå‰æ ‘ï¼ˆé€’å½’æˆ–å±‚åºè¾“å…¥ï¼‰          | O(n)            |
| æ’å…¥ï¼ˆInsertï¼‰      | åœ¨åˆé€‚ä½ç½®æ·»åŠ ç»“ç‚¹ï¼ˆå°¤å…¶åœ¨ BST ä¸­æœ‰è§„åˆ™ï¼‰ | O(log n) ~ O(n) |
| åˆ é™¤ï¼ˆDeleteï¼‰      | åˆ é™¤æŒ‡å®šç»“ç‚¹ï¼ˆä¸åŒæƒ…å†µåˆ†åˆ«å¤„ç†ï¼‰          | O(log n) ~ O(n) |
| æŸ¥æ‰¾ï¼ˆSearchï¼‰      | æŸ¥æ‰¾æŒ‡å®šç»“ç‚¹                              | O(log n) ~ O(n) |
| éå†ï¼ˆTraversalï¼‰   | æŒ‰ç‰¹å®šé¡ºåºè®¿é—®æ‰€æœ‰ç»“ç‚¹                    | O(n)            |
| æ±‚é«˜åº¦ï¼ˆHeightï¼‰    | è¿”å›æ ‘çš„æœ€å¤§æ·±åº¦                          | O(n)            |
| æ±‚ç»“ç‚¹ä¸ªæ•°ï¼ˆCountï¼‰ | ç»Ÿè®¡æ‰€æœ‰ç»“ç‚¹æ•°é‡                          | O(n)            |
| æ±‚å¶å­ç»“ç‚¹æ•°        | ç»Ÿè®¡æ²¡æœ‰å­ç»“ç‚¹çš„ç»“ç‚¹                      | O(n)            |
| åˆ¤ç©ºï¼ˆIsEmptyï¼‰     | åˆ¤æ–­æ˜¯å¦ä¸ºç©ºæ ‘                            | O(1)            |
| æ¸…ç©ºï¼ˆClearï¼‰       | åˆ é™¤æ‰€æœ‰ç»“ç‚¹                              | O(n)            |

------

## ğŸ§© ä¸‰ã€éå†æ“ä½œï¼ˆTraversalï¼‰

### 1ï¸âƒ£ æ·±åº¦ä¼˜å…ˆéå†ï¼ˆDFSï¼‰

- **å‰åºéå† (Preorder):** æ ¹ â†’ å·¦ â†’ å³
- **ä¸­åºéå† (Inorder):** å·¦ â†’ æ ¹ â†’ å³
- **ååºéå† (Postorder):** å·¦ â†’ å³ â†’ æ ¹

```python
# å‰åºéå†
def preorder(root):
    if root:
        print(root.val)
        preorder(root.left)
        preorder(root.right)
```

### 2ï¸âƒ£ å¹¿åº¦ä¼˜å…ˆéå†ï¼ˆBFSï¼‰

- **å±‚åºéå† (Level Order):** æŒ‰å±‚è®¿é—®

```python
from collections import deque
def level_order(root):
    if not root:
        return
    queue = deque([root])
    while queue:
        node = queue.popleft()
        print(node.val)
        if node.left: queue.append(node.left)
        if node.right: queue.append(node.right)
```

------

## ğŸŒ± å››ã€è¾…åŠ©æ“ä½œ

| æ“ä½œ             | ç¤ºä¾‹ä»£ç æ€è·¯                           |
| ---------------- | -------------------------------------- |
| æ±‚æ ‘é«˜           | `max(height(left), height(right)) + 1` |
| æ±‚å¶å­æ•°         | é€’å½’ç»Ÿè®¡å·¦å³å­æ ‘çš„å¶å­èŠ‚ç‚¹             |
| å¤åˆ¶æ ‘           | å¯¹æ¯ä¸ªç»“ç‚¹åˆ›å»ºæ–°ç»“ç‚¹å¹¶é€’å½’å¤åˆ¶         |
| åˆ¤æ–­ä¸¤æ ‘æ˜¯å¦ç›¸åŒ | æ¯”è¾ƒæ ¹èŠ‚ç‚¹ + å·¦å³å­æ ‘é€’å½’åˆ¤æ–­          |

------

## ğŸ§  äº”ã€äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰ç‰¹æœ‰æ“ä½œ

å¦‚æœæ˜¯ BSTï¼Œè¿˜å¯ä»¥æœ‰ä»¥ä¸‹æ“ä½œï¼š

| æ“ä½œ       | è¯´æ˜                              |
| ---------- | --------------------------------- |
| æ’å…¥       | å·¦å­æ ‘ < æ ¹ < å³å­æ ‘              |
| æŸ¥æ‰¾æœ€å°å€¼ | ä¸€ç›´å¾€å·¦èµ°                        |
| æŸ¥æ‰¾æœ€å¤§å€¼ | ä¸€ç›´å¾€å³èµ°                        |
| åˆ é™¤       | éœ€è¦è€ƒè™‘ 0ã€1ã€2 ä¸ªå­ç»“ç‚¹ä¸‰ç§æƒ…å†µ |

```python
from collections import deque
from typing import Optional, List, Generator, Any

class Node:
    """äºŒå‰æ ‘ç»“ç‚¹ï¼ˆç”¨äº BSTï¼‰"""
    def __init__(self, key: Any):
        self.key = key
        self.left: Optional['Node'] = None
        self.right: Optional['Node'] = None

    def __repr__(self):
        return f"Node({self.key!r})"


class BinarySearchTree:
    """
    äºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰å®ç° â€” ä¸å…è®¸ç›¸åŒé”®é‡å¤æ’å…¥ï¼ˆå¯æŒ‰éœ€ä¿®æ”¹ä¸ºè®¡æ•°ï¼‰ã€‚
    å¸¸ç”¨æ“ä½œï¼šinsert, search, delete, traversals, level order, min/max, height, count, leaves, clear, is_empty.
    """
    def __init__(self):
        self.root: Optional[Node] = None

    # ---------- æ’å…¥ ----------
    def insert(self, key: Any) -> None:
        """æ’å…¥ keyï¼ˆè¿­ä»£æ–¹å¼ï¼‰ã€‚è‹¥å·²å­˜åœ¨ï¼Œå½“å‰å®ç°å¿½ç•¥é‡å¤é”®ã€‚"""
        new_node = Node(key)
        if self.root is None:
            self.root = new_node
            return

        cur = self.root
        parent = None
        while cur:
            parent = cur
            if key < cur.key:
                cur = cur.left
            elif key > cur.key:
                cur = cur.right
            else:
                # å·²å­˜åœ¨ï¼Œå¿½ç•¥ï¼ˆæˆ–å¯ä»¥è®°å½•è®¡æ•°ï¼‰
                return

        if key < parent.key:
            parent.left = new_node
        else:
            parent.right = new_node

    # ---------- æŸ¥æ‰¾ ----------
    def search(self, key: Any) -> Optional[Node]:
        """åœ¨ BST ä¸­æŸ¥æ‰¾ keyï¼Œè¿”å›èŠ‚ç‚¹æˆ– Noneï¼ˆè¿­ä»£ï¼‰ã€‚"""
        cur = self.root
        while cur:
            if key == cur.key:
                return cur
            elif key < cur.key:
                cur = cur.left
            else:
                cur = cur.right
        return None

    # ---------- æœ€å°/æœ€å¤§ ----------
    def find_min(self, node: Optional[Node] = None) -> Optional[Node]:
        """æ‰¾åˆ°ä»¥ node ä¸ºæ ¹çš„å­æ ‘çš„æœ€å°ç»“ç‚¹ï¼ˆè‹¥ node ä¸º None åˆ™ä»æ ¹å¼€å§‹ï¼‰ã€‚"""
        cur = node if node is not None else self.root
        if cur is None:
            return None
        while cur.left:
            cur = cur.left
        return cur

    def find_max(self, node: Optional[Node] = None) -> Optional[Node]:
        """æ‰¾åˆ°ä»¥ node ä¸ºæ ¹çš„å­æ ‘çš„æœ€å¤§ç»“ç‚¹ï¼ˆè‹¥ node ä¸º None åˆ™ä»æ ¹å¼€å§‹ï¼‰ã€‚"""
        cur = node if node is not None else self.root
        if cur is None:
            return None
        while cur.right:
            cur = cur.right
        return cur

    # ---------- åˆ é™¤ ----------
    def delete(self, key: Any) -> bool:
        """
        åˆ é™¤ keyã€‚å¦‚æœåˆ é™¤æˆåŠŸè¿”å› Trueï¼Œkey ä¸å­˜åœ¨è¿”å› Falseã€‚
        ä½¿ç”¨æ ‡å‡† BST åˆ é™¤ï¼š0/1/2 å­ç»“ç‚¹ä¸‰ç§æƒ…å†µã€‚
        """
        self.root, deleted = self._delete_rec(self.root, key)
        return deleted

    def _delete_rec(self, node: Optional[Node], key: Any) -> (Optional[Node], bool):
        if node is None:
            return None, False

        if key < node.key:
            node.left, deleted = self._delete_rec(node.left, key)
            return node, deleted
        elif key > node.key:
            node.right, deleted = self._delete_rec(node.right, key)
            return node, deleted
        else:
            # æ‰¾åˆ°èŠ‚ç‚¹
            # æƒ…å†µ 1 & 2ï¼šè‡³å¤šä¸€ä¸ªå­èŠ‚ç‚¹
            if node.left is None:
                return node.right, True
            elif node.right is None:
                return node.left, True
            else:
                # æƒ…å†µ 3ï¼šä¸¤ä¸ªå­èŠ‚ç‚¹ -> æ‰¾åˆ°å³å­æ ‘çš„æœ€å°èŠ‚ç‚¹ï¼ˆåç»§ï¼‰ï¼Œæ›¿æ¢å€¼å¹¶åˆ é™¤åç»§èŠ‚ç‚¹
                succ = self.find_min(node.right)
                assert succ is not None  # node.right ä¸ä¸ºç©º
                node.key = succ.key
                node.right, _ = self._delete_rec(node.right, succ.key)
                return node, True

    # ---------- éå†ï¼ˆé€’å½’ï¼‰----------
    def inorder(self, node: Optional[Node] = None) -> Generator[Any, None, None]:
        """ä¸­åºéå†ï¼ˆå·¦-æ ¹-å³ï¼‰ï¼Œäº§ç”Ÿé”®çš„åºåˆ—ã€‚"""
        if node is None:
            node = self.root
        if node:
            yield from self.inorder(node.left)
            yield node.key
            yield from self.inorder(node.right)

    def preorder(self, node: Optional[Node] = None) -> Generator[Any, None, None]:
        """å‰åºéå†ï¼ˆæ ¹-å·¦-å³ï¼‰ã€‚"""
        if node is None:
            node = self.root
        if node:
            yield node.key
            yield from self.preorder(node.left)
            yield from self.preorder(node.right)

    def postorder(self, node: Optional[Node] = None) -> Generator[Any, None, None]:
        """ååºéå†ï¼ˆå·¦-å³-æ ¹ï¼‰ã€‚"""
        if node is None:
            node = self.root
        if node:
            yield from self.postorder(node.left)
            yield from self.postorder(node.right)
            yield node.key

    # ---------- éå†ï¼ˆè¿­ä»£ï¼‰----------
    def inorder_iter(self) -> List[Any]:
        """ä¸­åºéå†ï¼ˆè¿­ä»£ï¼‰ï¼Œè¿”å›åˆ—è¡¨ã€‚"""
        res = []
        stack: List[Node] = []
        cur = self.root
        while stack or cur:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack.pop()
            res.append(cur.key)
            cur = cur.right
        return res

    # ---------- å±‚åºéå† ----------
    def level_order(self) -> List[Any]:
        """å±‚åºéå†ï¼ˆå¹¿åº¦ä¼˜å…ˆï¼‰ï¼Œè¿”å›é”®åˆ—è¡¨ã€‚"""
        if self.root is None:
            return []
        q = deque([self.root])
        res = []
        while q:
            node = q.popleft()
            res.append(node.key)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        return res

    # ---------- é«˜åº¦ / èŠ‚ç‚¹è®¡æ•° / å¶å­è®¡æ•° ----------
    def height(self, node: Optional[Node] = None) -> int:
        """è¿”å›ä»¥ node ä¸ºæ ¹çš„æ ‘é«˜ï¼ˆæ ¹ä¸º 1ï¼‰ï¼Œé»˜è®¤ä»æ ¹å¼€å§‹ã€‚ç©ºæ ‘é«˜åº¦ä¸º 0ã€‚"""
        if node is None:
            node = self.root
        if node is None:
            return 0
        left_h = self.height(node.left)
        right_h = self.height(node.right)
        return max(left_h, right_h) + 1

    def count_nodes(self, node: Optional[Node] = None) -> int:
        """ç»Ÿè®¡ç»“ç‚¹æ€»æ•°ï¼ˆé€’å½’ï¼‰ã€‚"""
        if node is None:
            node = self.root
        if node is None:
            return 0
        return 1 + self.count_nodes(node.left) + self.count_nodes(node.right)

    def count_leaves(self, node: Optional[Node] = None) -> int:
        """ç»Ÿè®¡å¶å­ç»“ç‚¹ï¼ˆæ²¡æœ‰å­èŠ‚ç‚¹çš„ç»“ç‚¹ï¼‰ã€‚"""
        if node is None:
            node = self.root
        if node is None:
            return 0
        if node.left is None and node.right is None:
            return 1
        return self.count_leaves(node.left) + self.count_leaves(node.right)

    # ---------- è¾…åŠ© ----------
    def is_empty(self) -> bool:
        return self.root is None

    def clear(self) -> None:
        """æ¸…ç©ºæ ‘ï¼ˆæ–­å¼€å¼•ç”¨ï¼Œç­‰å¾… GCï¼‰ã€‚"""
        self.root = None

    # ---------- å¯è§†åŒ–å°å·¥å…· ----------
    def to_sorted_list(self) -> List[Any]:
        """è¿”å›ä¸­åºéå†çš„åˆ—è¡¨ï¼ˆå¯¹ BST æ¥è¯´æ˜¯å·²æ’åºåˆ—è¡¨ï¼‰ã€‚"""
        return list(self.inorder())

    def __repr__(self):
        return f"BinarySearchTree(root={self.root})"


# ---------------- ç¤ºä¾‹ç”¨æ³• ----------------
if __name__ == "__main__":
    bst = BinarySearchTree()
    for x in [50, 30, 70, 20, 40, 60, 80]:
        bst.insert(x)

    print("å±‚åº:", bst.level_order())            # [50,30,70,20,40,60,80]
    print("ä¸­åº:", bst.to_sorted_list())         # [20,30,40,50,60,70,80]
    print("å‰åº:", list(bst.preorder()))         # [50,30,20,40,70,60,80]
    print("ååº:", list(bst.postorder()))        # [20,40,30,60,80,70,50]
    print("ä¸­åº(è¿­ä»£):", bst.inorder_iter())     # [20,30,40,50,60,70,80]
    print("æœ€å°:", bst.find_min().key)           # 20
    print("æœ€å¤§:", bst.find_max().key)           # 80
    print("é«˜åº¦:", bst.height())                 # 3
    print("èŠ‚ç‚¹æ•°:", bst.count_nodes())          # 7
    print("å¶å­æ•°:", bst.count_leaves())         # 4

    print("æŸ¥æ‰¾ 40:", bst.search(40))            # Node(40)
    print("åˆ é™¤ 30:", bst.delete(30))            # True
    print("ä¸­åº after delete 30:", bst.to_sorted_list())  # [20,40,50,60,70,80]

    print("åˆ é™¤ä¸å­˜åœ¨ 999:", bst.delete(999))    # False
    bst.clear()
    print("æ¸…ç©ºå is_empty:", bst.is_empty())    # True

```









------

## 1) AVL æ ‘ï¼ˆé«˜åº¦å¹³è¡¡ï¼šæ¯ç»“ç‚¹å·¦å³å­æ ‘é«˜åº¦å·® â‰¤ 1ï¼‰

```python
# avl_tree.py
from typing import Optional, Any, Generator

class AVLNode:
    def __init__(self, key: Any):
        self.key = key
        self.left: Optional['AVLNode'] = None
        self.right: Optional['AVLNode'] = None
        self.height: int = 1

    def __repr__(self):
        return f"AVLNode({self.key})"

class AVLTree:
    def __init__(self):
        self.root: Optional[AVLNode] = None

    # Utility
    def _height(self, node: Optional[AVLNode]) -> int:
        return node.height if node else 0

    def _update_height(self, node: AVLNode) -> None:
        node.height = 1 + max(self._height(node.left), self._height(node.right))

    def _balance_factor(self, node: AVLNode) -> int:
        return self._height(node.left) - self._height(node.right)

    # Rotations
    def _rotate_right(self, y: AVLNode) -> AVLNode:
        x = y.left
        assert x is not None
        T2 = x.right
        x.right = y
        y.left = T2
        self._update_height(y)
        self._update_height(x)
        return x

    def _rotate_left(self, x: AVLNode) -> AVLNode:
        y = x.right
        assert y is not None
        T2 = y.left
        y.left = x
        x.right = T2
        self._update_height(x)
        self._update_height(y)
        return y

    # Insert
    def insert(self, key: Any) -> None:
        self.root = self._insert(self.root, key)

    def _insert(self, node: Optional[AVLNode], key: Any) -> AVLNode:
        if node is None:
            return AVLNode(key)
        if key < node.key:
            node.left = self._insert(node.left, key)
        elif key > node.key:
            node.right = self._insert(node.right, key)
        else:
            return node  # duplicate: ignore
        self._update_height(node)
        balance = self._balance_factor(node)

        # LL
        if balance > 1 and key < node.left.key:
            return self._rotate_right(node)
        # RR
        if balance < -1 and key > node.right.key:
            return self._rotate_left(node)
        # LR
        if balance > 1 and key > node.left.key:
            node.left = self._rotate_left(node.left)
            return self._rotate_right(node)
        # RL
        if balance < -1 and key < node.right.key:
            node.right = self._rotate_right(node.right)
            return self._rotate_left(node)

        return node

    # Search
    def search(self, key: Any) -> Optional[AVLNode]:
        cur = self.root
        while cur:
            if key == cur.key:
                return cur
            cur = cur.left if key < cur.key else cur.right
        return None

    # Min/Max
    def find_min(self, node: Optional[AVLNode]=None) -> Optional[AVLNode]:
        cur = node or self.root
        if cur is None: return None
        while cur.left:
            cur = cur.left
        return cur

    def find_max(self, node: Optional[AVLNode]=None) -> Optional[AVLNode]:
        cur = node or self.root
        if cur is None: return None
        while cur.right:
            cur = cur.right
        return cur

    # Delete
    def delete(self, key: Any) -> None:
        self.root = self._delete(self.root, key)

    def _delete(self, node: Optional[AVLNode], key: Any) -> Optional[AVLNode]:
        if node is None:
            return None
        if key < node.key:
            node.left = self._delete(node.left, key)
        elif key > node.key:
            node.right = self._delete(node.right, key)
        else:
            # found
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            else:
                succ = self.find_min(node.right)
                assert succ is not None
                node.key = succ.key
                node.right = self._delete(node.right, succ.key)
        # update and rebalance
        self._update_height(node)
        balance = self._balance_factor(node)
        # LL
        if balance > 1 and self._balance_factor(node.left) >= 0:
            return self._rotate_right(node)
        # LR
        if balance > 1 and self._balance_factor(node.left) < 0:
            node.left = self._rotate_left(node.left)
            return self._rotate_right(node)
        # RR
        if balance < -1 and self._balance_factor(node.right) <= 0:
            return self._rotate_left(node)
        # RL
        if balance < -1 and self._balance_factor(node.right) > 0:
            node.right = self._rotate_right(node.right)
            return self._rotate_left(node)
        return node

    # Traversals
    def inorder(self) -> Generator[Any, None, None]:
        def _in(n):
            if not n: return
            yield from _in(n.left)
            yield n.key
            yield from _in(n.right)
        yield from _in(self.root)

# Example usage
if __name__ == "__main__":
    a = AVLTree()
    for v in [20, 4, 15, 70, 50, 100, 80]:
        a.insert(v)
    print("AVL inorder:", list(a.inorder()))
    a.delete(70)
    print("After delete 70:", list(a.inorder()))
```

------

## 2) Treapï¼ˆéšæœºåŒ–å¹³è¡¡ï¼šBST + heapï¼ˆä¼˜å…ˆçº§ï¼‰ï¼‰

Treap çš„æ€æƒ³ç®€å•ä¸”å®ç°è¾ƒçŸ­ï¼šæ¯ä¸ªèŠ‚ç‚¹æœ‰éšæœº priorityï¼Œæ»¡è¶³ BST çš„é”®åºå’Œ heap çš„ä¼˜å…ˆçº§ï¼ˆpriority è¾ƒå°/å¤§çœ‹å®ç°ï¼‰ã€‚æ’å…¥åé€šè¿‡æ—‹è½¬æ¢å¤ heap æ€§è´¨ï¼›åˆ é™¤ä¹Ÿé€šè¿‡æ—‹è½¬ä¸‹æ²‰å†åˆ é™¤å¶å­ï¼Œæ¯”è¾ƒç›´è§‚ã€‚

```python
# treap.py
import random
from typing import Optional, Any, Generator

class TreapNode:
    def __init__(self, key: Any, priority: Optional[int]=None):
        self.key = key
        self.priority = priority if priority is not None else random.randrange(1 << 30)
        self.left: Optional['TreapNode'] = None
        self.right: Optional['TreapNode'] = None

    def __repr__(self):
        return f"TreapNode({self.key}, p={self.priority})"

class Treap:
    def __init__(self):
        self.root: Optional[TreapNode] = None

    # rotations
    def _rotate_right(self, y: TreapNode) -> TreapNode:
        x = y.left
        assert x is not None
        y.left = x.right
        x.right = y
        return x

    def _rotate_left(self, x: TreapNode) -> TreapNode:
        y = x.right
        assert y is not None
        x.right = y.left
        y.left = x
        return y

    # insert
    def insert(self, key: Any) -> None:
        self.root = self._insert(self.root, key)

    def _insert(self, node: Optional[TreapNode], key: Any) -> TreapNode:
        if node is None:
            return TreapNode(key)
        if key < node.key:
            node.left = self._insert(node.left, key)
            if node.left.priority < node.priority:
                node = self._rotate_right(node)
        elif key > node.key:
            node.right = self._insert(node.right, key)
            if node.right.priority < node.priority:
                node = self._rotate_left(node)
        else:
            pass  # duplicate ignore
        return node

    # search
    def search(self, key: Any) -> Optional[TreapNode]:
        cur = self.root
        while cur:
            if key == cur.key:
                return cur
            cur = cur.left if key < cur.key else cur.right
        return None

    # delete
    def delete(self, key: Any) -> None:
        self.root = self._delete(self.root, key)

    def _delete(self, node: Optional[TreapNode], key: Any) -> Optional[TreapNode]:
        if node is None:
            return None
        if key < node.key:
            node.left = self._delete(node.left, key)
        elif key > node.key:
            node.right = self._delete(node.right, key)
        else:
            # node to remove: rotate it down until leaf
            if node.left is None and node.right is None:
                return None
            elif node.left is None:
                node = self._rotate_left(node)
                node.left = self._delete(node.left, key)
            elif node.right is None:
                node = self._rotate_right(node)
                node.right = self._delete(node.right, key)
            else:
                # rotate toward the child with smaller priority
                if node.left.priority < node.right.priority:
                    node = self._rotate_right(node)
                    node.right = self._delete(node.right, key)
                else:
                    node = self._rotate_left(node)
                    node.left = self._delete(node.left, key)
        return node

    # traversals
    def inorder(self) -> Generator[Any, None, None]:
        def _in(n):
            if not n: return
            yield from _in(n.left)
            yield n.key
            yield from _in(n.right)
        yield from _in(self.root)

# Example usage
if __name__ == "__main__":
    t = Treap()
    for v in [50, 30, 70, 20, 40, 60, 80]:
        t.insert(v)
    print("Treap inorder:", list(t.inorder()))
    t.delete(30)
    print("After delete 30:", list(t.inorder()))
```

------

## 3) çº¢é»‘æ ‘ï¼ˆRed-Black Tree, RBTreeï¼‰

çº¢é»‘æ ‘å®ç°æœ€å¤æ‚â€”â€”æ’å…¥æ¶‰åŠé¢œè‰²ä¸æ—‹è½¬ï¼Œåˆ é™¤æ›´æ˜¯ç¹å¤ã€‚ä¸‹é¢æä¾›ä¸€ä¸ª**å®Œæ•´çš„çº¢é»‘æ ‘å®ç°**ï¼ˆå«æ’å…¥ã€åˆ é™¤ã€æœç´¢ã€éå†ï¼‰ã€‚å®ç°éµå¾ª CLRS é£æ ¼ï¼ˆ`color` å­—æ®µï¼š 'red' / 'black'ï¼‰ï¼Œå¹¶ä½¿ç”¨å“¨å…µ `NIL` èŠ‚ç‚¹æ¥ç®€åŒ–è¾¹ç•Œæ¡ä»¶ã€‚

> æ³¨æ„ï¼šçº¢é»‘æ ‘åˆ é™¤é€»è¾‘ç¹çï¼Œä½†ä¸‹é¢å®ç°æ˜¯å®Œæ•´çš„ã€å¯è¿è¡Œçš„ï¼›è‹¥ä½ åªéœ€è¦â€œæ’å…¥+æŸ¥æ‰¾+éå†â€ï¼Œä¹Ÿå¯ä»¥åªç”¨é‚£éƒ¨åˆ†ã€‚

```python
# rbtree.py
from typing import Optional, Any, Generator

class RBNode:
    def __init__(self, key: Any, color: str='red', left: Optional['RBNode']=None, right: Optional['RBNode']=None, parent: Optional['RBNode']=None):
        self.key = key
        self.color = color  # 'red' or 'black'
        self.left = left
        self.right = right
        self.parent = parent

    def __repr__(self):
        return f"RBNode({self.key},{self.color})"

class RedBlackTree:
    def __init__(self):
        # sentinel NIL node
        self.NIL = RBNode(key=None, color='black')
        self.NIL.left = self.NIL.right = self.NIL.parent = self.NIL
        self.root: RBNode = self.NIL

    # Left rotate
    def _left_rotate(self, x: RBNode) -> None:
        y = x.right
        assert y is not self.NIL
        x.right = y.left
        if y.left is not self.NIL:
            y.left.parent = x
        y.parent = x.parent
        if x.parent is self.NIL:
            self.root = y
        elif x is x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        y.left = x
        x.parent = y

    # Right rotate
    def _right_rotate(self, y: RBNode) -> None:
        x = y.left
        assert x is not self.NIL
        y.left = x.right
        if x.right is not self.NIL:
            x.right.parent = y
        x.parent = y.parent
        if y.parent is self.NIL:
            self.root = x
        elif y is y.parent.right:
            y.parent.right = x
        else:
            y.parent.left = x
        x.right = y
        y.parent = x

    # Insert
    def insert(self, key: Any) -> None:
        node = RBNode(key=key, color='red', left=self.NIL, right=self.NIL, parent=self.NIL)
        y = self.NIL
        x = self.root
        while x is not self.NIL:
            y = x
            x = x.left if node.key < x.key else x.right if node.key > x.key else None
            if x is None:
                # duplicate key: ignore
                return
        node.parent = y
        if y is self.NIL:
            self.root = node
        elif node.key < y.key:
            y.left = node
        else:
            y.right = node
        node.left = self.NIL
        node.right = self.NIL
        node.color = 'red'
        self._insert_fixup(node)

    def _insert_fixup(self, z: RBNode) -> None:
        while z.parent.color == 'red':
            if z.parent is z.parent.parent.left:
                y = z.parent.parent.right
                if y.color == 'red':
                    # case 1
                    z.parent.color = 'black'
                    y.color = 'black'
                    z.parent.parent.color = 'red'
                    z = z.parent.parent
                else:
                    if z is z.parent.right:
                        # case 2
                        z = z.parent
                        self._left_rotate(z)
                    # case 3
                    z.parent.color = 'black'
                    z.parent.parent.color = 'red'
                    self._right_rotate(z.parent.parent)
            else:
                y = z.parent.parent.left
                if y.color == 'red':
                    z.parent.color = 'black'
                    y.color = 'black'
                    z.parent.parent.color = 'red'
                    z = z.parent.parent
                else:
                    if z is z.parent.left:
                        z = z.parent
                        self._right_rotate(z)
                    z.parent.color = 'black'
                    z.parent.parent.color = 'red'
                    self._left_rotate(z.parent.parent)
        self.root.color = 'black'

    # Transplant (helper for delete)
    def _transplant(self, u: RBNode, v: RBNode) -> None:
        if u.parent is self.NIL:
            self.root = v
        elif u is u.parent.left:
            u.parent.left = v
        else:
            u.parent.right = v
        v.parent = u.parent

    # Minimum from node
    def _minimum(self, x: RBNode) -> RBNode:
        while x.left is not self.NIL:
            x = x.left
        return x

    # Delete
    def delete(self, key: Any) -> bool:
        z = self._search_node(self.root, key)
        if z is self.NIL:
            return False
        y = z
        y_original_color = y.color
        if z.left is self.NIL:
            x = z.right
            self._transplant(z, z.right)
        elif z.right is self.NIL:
            x = z.left
            self._transplant(z, z.left)
        else:
            y = self._minimum(z.right)
            y_original_color = y.color
            x = y.right
            if y.parent is z:
                x.parent = y
            else:
                self._transplant(y, y.right)
                y.right = z.right
                y.right.parent = y
            self._transplant(z, y)
            y.left = z.left
            y.left.parent = y
            y.color = z.color
        if y_original_color == 'black':
            self._delete_fixup(x)
        return True

    def _delete_fixup(self, x: RBNode) -> None:
        while x is not self.root and x.color == 'black':
            if x is x.parent.left:
                w = x.parent.right
                if w.color == 'red':
                    w.color = 'black'
                    x.parent.color = 'red'
                    self._left_rotate(x.parent)
                    w = x.parent.right
                if w.left.color == 'black' and w.right.color == 'black':
                    w.color = 'red'
                    x = x.parent
                else:
                    if w.right.color == 'black':
                        w.left.color = 'black'
                        w.color = 'red'
                        self._right_rotate(w)
                        w = x.parent.right
                    w.color = x.parent.color
                    x.parent.color = 'black'
                    w.right.color = 'black'
                    self._left_rotate(x.parent)
                    x = self.root
            else:
                w = x.parent.left
                if w.color == 'red':
                    w.color = 'black'
                    x.parent.color = 'red'
                    self._right_rotate(x.parent)
                    w = x.parent.left
                if w.right.color == 'black' and w.left.color == 'black':
                    w.color = 'red'
                    x = x.parent
                else:
                    if w.left.color == 'black':
                        w.right.color = 'black'
                        w.color = 'red'
                        self._left_rotate(w)
                        w = x.parent.left
                    w.color = x.parent.color
                    x.parent.color = 'black'
                    w.left.color = 'black'
                    self._right_rotate(x.parent)
                    x = self.root
        x.color = 'black'

    # Search
    def _search_node(self, node: RBNode, key: Any) -> RBNode:
        while node is not self.NIL:
            if key == node.key:
                return node
            node = node.left if key < node.key else node.right
        return self.NIL

    def search(self, key: Any) -> Optional[RBNode]:
        n = self._search_node(self.root, key)
        return None if n is self.NIL else n

    # Traversal (inorder)
    def inorder(self) -> Generator[Any, None, None]:
        def _in(n):
            if n is self.NIL:
                return
            yield from _in(n.left)
            yield n.key
            yield from _in(n.right)
        yield from _in(self.root)

# Example usage
if __name__ == "__main__":
    r = RedBlackTree()
    for v in [41, 38, 31, 12, 19, 8]:
        r.insert(v)
    print("RB inorder:", list(r.inorder()))
    r.delete(38)
    print("After delete 38:", list(r.inorder()))
```

------

## å°ç»“ä¸å»ºè®®

- **AVL**ï¼šä¸¥æ ¼é«˜åº¦å¹³è¡¡ï¼ŒæŸ¥æ‰¾é€Ÿåº¦ç¨³å®šä¸”å¸¸æ¯” RB æ ‘å°‘ä¸€æ¬¡æ—‹è½¬ï¼Œä½†æ’å…¥/åˆ é™¤æ—¶æ—‹è½¬è°ƒæ•´é¢‘ç‡å¯èƒ½æ›´é«˜ï¼Œé€‚åˆè¯»å¤šå†™å°‘çš„åœºæ™¯ã€‚
- **Treap**ï¼šå®ç°æœ€ç®€å•ã€ä»£ç çŸ­ã€å°æ¦‚ç‡é€€åŒ–ä¸”å¹³å‡å¤æ‚åº¦ä¼˜ç§€ï¼›ç”±äºä½¿ç”¨éšæœºä¼˜å…ˆçº§ï¼Œé€šå¸¸é€‚åˆéœ€è¦æ¦‚ç‡æ€§ä¿è¯çš„åœºæ™¯ã€‚
- **çº¢é»‘æ ‘**ï¼šå·¥ä¸šç•Œå¸¸ç”¨ï¼ˆä¾‹å¦‚ Java çš„ TreeMap/TreeSetã€Linux å†…æ ¸ã€å¾ˆå¤šæ ‡å‡†åº“å®ç°ï¼‰ï¼Œåˆ é™¤/æ’å…¥å¹³è¡¡æ€§å¥½ï¼Œä¿è¯æœ€åæƒ…å½¢ä¸‹ O(log n)ã€‚

