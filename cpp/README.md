# 稀疏矩阵的表示与转置 - 代码说明文档

## 一、三元组顺序表实现（数组）

### 1.1 数据结构

```cpp
struct Triple {
    int row;    // 行下标
    int col;    // 列下标
    int value;  // 元素值
};

class TripleMatrix {
    Triple data[MAXSIZE];  // 非零元素数组
    int rows;              // 矩阵行数
    int cols;              // 矩阵列数
    int nums;              // 非零元素个数
};
```

### 1.2 快速转置算法原理

**时间复杂度：O(m + n)，其中m为非零元素个数，n为列数**

算法步骤：
1. 统计原矩阵每列的非零元素个数 → num[]
2. 计算每列第一个元素在转置矩阵中的位置 → cpot[]
3. 按原矩阵顺序依次转置每个元素到正确位置

**关键公式：**
```
cpot[0] = 0
cpot[col] = cpot[col-1] + num[col-1]  (col > 0)
```

**示例：**
```
原矩阵 (5x6):
列号:  0  1  2  3  4  5
     [ 0  2  0  0  3  0 ]
     [ 0  0  4  0  0  0 ]
     [ 5  0  0  6  0  0 ]
     [ 0  7  0  0  0  8 ]
     [ 0  0  0  9  0  0 ]

num[]  = {1, 2, 1, 2, 1, 1}  (每列非零元素个数)
cpot[] = {0, 1, 3, 4, 6, 7}  (每列在转置后的起始位置)

转置后 (6x5):
     [ 0  0  5  0  0 ]
     [ 2  0  0  7  0 ]
     [ 0  4  0  0  0 ]
     [ 0  0  6  0  9 ]
     [ 3  0  0  0  0 ]
     [ 0  0  0  8  0 ]
```

### 1.3 普通转置算法

**时间复杂度：O(m × n)，其中m为非零元素个数，n为列数**

按列序遍历原矩阵，依次找出每列的元素进行转置。

---

## 二、十字链表实现（广义表）

### 2.1 数据结构

```cpp
struct CrossNode {
    int row, col;           // 行号、列号
    int value;              // 元素值
    CrossNode *right;       // 指向同行下一个元素
    CrossNode *down;        // 指向同列下一个元素
};

class CrossListMatrix {
    CrossNode **rowHead;    // 行头指针数组
    CrossNode **colHead;    // 列头指针数组
    int rows, cols, nums;
};
```

### 2.2 结构示意图

```
        colHead[0]  colHead[1]  colHead[2]  colHead[3]  colHead[4]  colHead[5]
           ↓          ↓           ↓           ↓           ↓           ↓
rowHead[0] → (0,1,2) ────────────────────────→ (0,4,3)
           ↓    ↓
rowHead[1]      │      (1,2,4)
           ↓    ↓        ↓
rowHead[2] (2,0,5)      │      (2,3,6)
           ↓    ↓        ↓        ↓
rowHead[3]    (3,1,7) ────────────────────────────────→ (3,5,8)
           ↓    ↓        ↓        ↓
rowHead[4]      │      (4,3,9)
                ↓        ↓        ↓
```

### 2.3 优势

1. **灵活性**：便于插入和删除元素
2. **遍历效率**：
   - 按行遍历：沿right指针
   - 按列遍历：沿down指针
3. **矩阵运算**：便于实现矩阵加法、乘法等运算

### 2.4 插入算法

插入元素(r, c, v)需要：
1. 在第r行链表中按列号递增顺序插入（维护right指针）
2. 在第c列链表中按行号递增顺序插入（维护down指针）

**时间复杂度：O(max(行长度, 列长度))**

---

## 三、两种表示法对比

| 特性 | 三元组顺序表 | 十字链表 |
|------|-------------|----------|
| 存储结构 | 数组（顺序存储） | 链表（链式存储） |
| 空间复杂度 | O(非零元素个数) | O(非零元素个数) |
| 随机访问 | O(非零元素个数) | O(行长度或列长度) |
| 转置效率 | 快速转置O(m+n) | 需重建链表O(m) |
| 插入删除 | 不便，需移动元素 | 便利，调整指针 |
| 适用场景 | 静态矩阵、转置运算 | 动态矩阵、矩阵运算 |

---

## 四、编译和运行

### 4.1 编译
```bash
g++ -o sparse_matrix sparse_matrix.cpp -std=c++11
```

### 4.2 运行
```bash
./sparse_matrix
```

### 4.3 输入格式

程序会提示输入非零元素，格式为：
```
行号 列号 值
```

示例：
```
0 1 2
0 4 3
1 2 4
...
```

---

## 五、测试用例

### 测试用例1：5×6稀疏矩阵
```
矩阵规模: 5行 × 6列
非零元素: 8个
非零比率: 8/30 ≈ 26.7%

输入数据:
0 1 2
0 4 3
1 2 4
2 0 5
2 3 6
3 1 7
3 5 8
4 3 9
```

### 测试用例2：大规模稀疏矩阵
```
矩阵规模: 1000行 × 1000列
非零元素: 100个
非零比率: 0.01%

典型的稀疏矩阵，能很好体现存储优势。
```

---

## 六、扩展功能建议

1. **矩阵加法**：两个稀疏矩阵相加
2. **矩阵乘法**：稀疏矩阵乘法
3. **文件读写**：从文件读取/保存矩阵
4. **性能测试**：比较不同算法的运行时间
5. **内存分析**：分析内存使用情况

---

## 七、注意事项

1. 输入的行列号要在有效范围内 (0 ≤ row < rows, 0 ≤ col < cols)
2. 零元素不会被存储
3. 三元组表中元素按行优先顺序存储（行号递增，同行内列号递增）
4. 十字链表中每行、每列的元素都按序排列

---

## 八、算法复杂度总结

| 操作 | 三元组顺序表 | 十字链表 |
|------|-------------|----------|
| 创建 | O(m log m) | O(m × k) |
| 转置 | O(m + n) | O(m) |
| 访问元素 | O(m) | O(k) |
| 插入元素 | O(m) | O(k) |
| 删除元素 | O(m) | O(k) |

其中：
- m = 非零元素个数
- n = 矩阵列数
- k = 平均行/列非零元素个数
