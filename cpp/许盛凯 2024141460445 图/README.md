# 图算法练习说明


## graph1.cpp — DFS 列举所有路径
- **题目**：在一个顶点编号为 `1..n` 的有向图中，输出所有从 `1` 到 `n` 的路径；如果不存在则输出 `-1`。
- **输入**：第一行 `n m`，随后 `m` 行是 1 基边 `s t`。
- **思路**：对邻接表 `vector<list<int>>` 做深度优先搜索，全局 `path` 保存当前路径，搜索到 `n` 就把 `path` 拷贝到 `result`。
- **复杂度**：与简单路径条数成正比；每条记录的路径中每条边只会被递归访问一次。

## graph2.cpp — DFS 统计岛屿数量
- **题目**：在二维 0/1 网格中统计由 `'1'` 组成、四联通的岛屿个数。
- **输入**：`m n` 以及 `m × n` 的字符网格（每格 `0` 或 `1`）。
- **思路**：遍历所有单元格，遇到尚未访问的陆地就 DFS 把整个岛屿淹没（标记为 `'2'`），并将岛屿计数加一。
- **复杂度**：时间 `O(m·n)`，最坏情况下递归栈也为 `O(m·n)`。

## graph3.cpp — 按字典序输出简单路径
- **题目**：与 `graph1.cpp` 类似，但需要按字典序输出路径，且路径中顶点不能重复。
- **输入**：`n m` 后接 `m` 条有向边。
- **思路**：构建 `vector<vector<int>>` 邻接表，对每个邻接表排序，然后用 `visited` 数组剪枝的 DFS 记录所有从 `1` 到 `n` 的简单路径；若结果为空输出 `-1`。
- **复杂度**：同样受简单路径数量限制，额外的排序代价约 `O(m log m)`。

## graph4.cpp — 多源 BFS 求遍历所有点的最短路
- **题目**：在无向图中找一条最短的行走路径，使得所有节点都被访问一次以上（LeetCode 847 的状态压缩 BFS）。
- **输入**：第一行 `n`，之后每行先给邻接点数量 `m`，再给 `m` 个邻居（代码按 0 基读取）。
- **思路**：把状态定义为 `(node, mask)`，`mask` 表示已访问的集合。把所有节点都作为起点入队，BFS 扩展并在 `mask == (1<<n)-1` 时返回距离。使用队列和 `visited[node][mask]` 记录。
- **复杂度**：状态和转移规模约为 `O(n·2^n)`。

## Prim.cpp — 基于 Prim 的曼哈顿 MST
- **题目**：给定平面上 `n` 个点，用曼哈顿距离建立完全图，求最小生成树。
- **输入**：`n` 以及 `n` 行 `x y` 坐标。
- **思路**：先建 `n × n` 距离矩阵，再用数组版 Prim（`lowCost`、`used`），逐步把最近的顶点加入 MST；若图不连通（完全图不会发生）则返回 `-1`。
- **复杂度**：建矩阵 `O(n^2)`，Prim 主循环也是 `O(n^2)`。

## Kruskal.cpp — Kruskal + 并查集
- **题目**：同样的曼哈顿最小生成树问题，但改用 Kruskal 算法。
- **输入**：与 `Prim.cpp` 相同。
- **思路**：枚举 `n(n-1)/2` 条边并计算权值，整体排序后用带路径压缩和按秩合并的并查集逐条尝试，把成功联通的边加入答案，直到取够 `n-1` 条。
- **复杂度**：生成边 `O(n^2)`，排序 `O(n^2 log n)`，并查集合并近似线性。

## 使用提示
1. 使用 `g++ file.cpp -std=c++17 -O2` 编译任意文件。
2. 输入需符合上述格式；大部分程序读到 EOF 并输出计算结果或在无解时输出 `-1`。
