## 🌳 一、二叉树的基本概念

- **二叉树**是一种每个结点最多有两个子结点的树形结构。
- 通常包括：
  - **左子树（Left Subtree）**
  - **右子树（Right Subtree）**
- 特殊类型：
  - 满二叉树（Full Binary Tree）
  - 完全二叉树（Complete Binary Tree）
  - 二叉搜索树（BST, Binary Search Tree）

------

## ⚙️ 二、二叉树的基本操作

| 操作                | 说明                                      | 时间复杂度      |
| ------------------- | ----------------------------------------- | --------------- |
| 创建（Create）      | 构建一棵二叉树（递归或层序输入）          | O(n)            |
| 插入（Insert）      | 在合适位置添加结点（尤其在 BST 中有规则） | O(log n) ~ O(n) |
| 删除（Delete）      | 删除指定结点（不同情况分别处理）          | O(log n) ~ O(n) |
| 查找（Search）      | 查找指定结点                              | O(log n) ~ O(n) |
| 遍历（Traversal）   | 按特定顺序访问所有结点                    | O(n)            |
| 求高度（Height）    | 返回树的最大深度                          | O(n)            |
| 求结点个数（Count） | 统计所有结点数量                          | O(n)            |
| 求叶子结点数        | 统计没有子结点的结点                      | O(n)            |
| 判空（IsEmpty）     | 判断是否为空树                            | O(1)            |
| 清空（Clear）       | 删除所有结点                              | O(n)            |

------

## 🧩 三、遍历操作（Traversal）

### 1️⃣ 深度优先遍历（DFS）

- **前序遍历 (Preorder):** 根 → 左 → 右
- **中序遍历 (Inorder):** 左 → 根 → 右
- **后序遍历 (Postorder):** 左 → 右 → 根

```python
# 前序遍历
def preorder(root):
    if root:
        print(root.val)
        preorder(root.left)
        preorder(root.right)
```

### 2️⃣ 广度优先遍历（BFS）

- **层序遍历 (Level Order):** 按层访问

```python
from collections import deque
def level_order(root):
    if not root:
        return
    queue = deque([root])
    while queue:
        node = queue.popleft()
        print(node.val)
        if node.left: queue.append(node.left)
        if node.right: queue.append(node.right)
```

------

## 🌱 四、辅助操作

| 操作             | 示例代码思路                           |
| ---------------- | -------------------------------------- |
| 求树高           | `max(height(left), height(right)) + 1` |
| 求叶子数         | 递归统计左右子树的叶子节点             |
| 复制树           | 对每个结点创建新结点并递归复制         |
| 判断两树是否相同 | 比较根节点 + 左右子树递归判断          |

------

## 🧠 五、二叉搜索树（BST）特有操作

如果是 BST，还可以有以下操作：

| 操作       | 说明                              |
| ---------- | --------------------------------- |
| 插入       | 左子树 < 根 < 右子树              |
| 查找最小值 | 一直往左走                        |
| 查找最大值 | 一直往右走                        |
| 删除       | 需要考虑 0、1、2 个子结点三种情况 |

```python
from collections import deque
from typing import Optional, List, Generator, Any

class Node:
    """二叉树结点（用于 BST）"""
    def __init__(self, key: Any):
        self.key = key
        self.left: Optional['Node'] = None
        self.right: Optional['Node'] = None

    def __repr__(self):
        return f"Node({self.key!r})"


class BinarySearchTree:
    """
    二叉搜索树（BST）实现 — 不允许相同键重复插入（可按需修改为计数）。
    常用操作：insert, search, delete, traversals, level order, min/max, height, count, leaves, clear, is_empty.
    """
    def __init__(self):
        self.root: Optional[Node] = None

    # ---------- 插入 ----------
    def insert(self, key: Any) -> None:
        """插入 key（迭代方式）。若已存在，当前实现忽略重复键。"""
        new_node = Node(key)
        if self.root is None:
            self.root = new_node
            return

        cur = self.root
        parent = None
        while cur:
            parent = cur
            if key < cur.key:
                cur = cur.left
            elif key > cur.key:
                cur = cur.right
            else:
                # 已存在，忽略（或可以记录计数）
                return

        if key < parent.key:
            parent.left = new_node
        else:
            parent.right = new_node

    # ---------- 查找 ----------
    def search(self, key: Any) -> Optional[Node]:
        """在 BST 中查找 key，返回节点或 None（迭代）。"""
        cur = self.root
        while cur:
            if key == cur.key:
                return cur
            elif key < cur.key:
                cur = cur.left
            else:
                cur = cur.right
        return None

    # ---------- 最小/最大 ----------
    def find_min(self, node: Optional[Node] = None) -> Optional[Node]:
        """找到以 node 为根的子树的最小结点（若 node 为 None 则从根开始）。"""
        cur = node if node is not None else self.root
        if cur is None:
            return None
        while cur.left:
            cur = cur.left
        return cur

    def find_max(self, node: Optional[Node] = None) -> Optional[Node]:
        """找到以 node 为根的子树的最大结点（若 node 为 None 则从根开始）。"""
        cur = node if node is not None else self.root
        if cur is None:
            return None
        while cur.right:
            cur = cur.right
        return cur

    # ---------- 删除 ----------
    def delete(self, key: Any) -> bool:
        """
        删除 key。如果删除成功返回 True，key 不存在返回 False。
        使用标准 BST 删除：0/1/2 子结点三种情况。
        """
        self.root, deleted = self._delete_rec(self.root, key)
        return deleted

    def _delete_rec(self, node: Optional[Node], key: Any) -> (Optional[Node], bool):
        if node is None:
            return None, False

        if key < node.key:
            node.left, deleted = self._delete_rec(node.left, key)
            return node, deleted
        elif key > node.key:
            node.right, deleted = self._delete_rec(node.right, key)
            return node, deleted
        else:
            # 找到节点
            # 情况 1 & 2：至多一个子节点
            if node.left is None:
                return node.right, True
            elif node.right is None:
                return node.left, True
            else:
                # 情况 3：两个子节点 -> 找到右子树的最小节点（后继），替换值并删除后继节点
                succ = self.find_min(node.right)
                assert succ is not None  # node.right 不为空
                node.key = succ.key
                node.right, _ = self._delete_rec(node.right, succ.key)
                return node, True

    # ---------- 遍历（递归）----------
    def inorder(self, node: Optional[Node] = None) -> Generator[Any, None, None]:
        """中序遍历（左-根-右），产生键的序列。"""
        if node is None:
            node = self.root
        if node:
            yield from self.inorder(node.left)
            yield node.key
            yield from self.inorder(node.right)

    def preorder(self, node: Optional[Node] = None) -> Generator[Any, None, None]:
        """前序遍历（根-左-右）。"""
        if node is None:
            node = self.root
        if node:
            yield node.key
            yield from self.preorder(node.left)
            yield from self.preorder(node.right)

    def postorder(self, node: Optional[Node] = None) -> Generator[Any, None, None]:
        """后序遍历（左-右-根）。"""
        if node is None:
            node = self.root
        if node:
            yield from self.postorder(node.left)
            yield from self.postorder(node.right)
            yield node.key

    # ---------- 遍历（迭代）----------
    def inorder_iter(self) -> List[Any]:
        """中序遍历（迭代），返回列表。"""
        res = []
        stack: List[Node] = []
        cur = self.root
        while stack or cur:
            while cur:
                stack.append(cur)
                cur = cur.left
            cur = stack.pop()
            res.append(cur.key)
            cur = cur.right
        return res

    # ---------- 层序遍历 ----------
    def level_order(self) -> List[Any]:
        """层序遍历（广度优先），返回键列表。"""
        if self.root is None:
            return []
        q = deque([self.root])
        res = []
        while q:
            node = q.popleft()
            res.append(node.key)
            if node.left:
                q.append(node.left)
            if node.right:
                q.append(node.right)
        return res

    # ---------- 高度 / 节点计数 / 叶子计数 ----------
    def height(self, node: Optional[Node] = None) -> int:
        """返回以 node 为根的树高（根为 1），默认从根开始。空树高度为 0。"""
        if node is None:
            node = self.root
        if node is None:
            return 0
        left_h = self.height(node.left)
        right_h = self.height(node.right)
        return max(left_h, right_h) + 1

    def count_nodes(self, node: Optional[Node] = None) -> int:
        """统计结点总数（递归）。"""
        if node is None:
            node = self.root
        if node is None:
            return 0
        return 1 + self.count_nodes(node.left) + self.count_nodes(node.right)

    def count_leaves(self, node: Optional[Node] = None) -> int:
        """统计叶子结点（没有子节点的结点）。"""
        if node is None:
            node = self.root
        if node is None:
            return 0
        if node.left is None and node.right is None:
            return 1
        return self.count_leaves(node.left) + self.count_leaves(node.right)

    # ---------- 辅助 ----------
    def is_empty(self) -> bool:
        return self.root is None

    def clear(self) -> None:
        """清空树（断开引用，等待 GC）。"""
        self.root = None

    # ---------- 可视化小工具 ----------
    def to_sorted_list(self) -> List[Any]:
        """返回中序遍历的列表（对 BST 来说是已排序列表）。"""
        return list(self.inorder())

    def __repr__(self):
        return f"BinarySearchTree(root={self.root})"


# ---------------- 示例用法 ----------------
if __name__ == "__main__":
    bst = BinarySearchTree()
    for x in [50, 30, 70, 20, 40, 60, 80]:
        bst.insert(x)

    print("层序:", bst.level_order())            # [50,30,70,20,40,60,80]
    print("中序:", bst.to_sorted_list())         # [20,30,40,50,60,70,80]
    print("前序:", list(bst.preorder()))         # [50,30,20,40,70,60,80]
    print("后序:", list(bst.postorder()))        # [20,40,30,60,80,70,50]
    print("中序(迭代):", bst.inorder_iter())     # [20,30,40,50,60,70,80]
    print("最小:", bst.find_min().key)           # 20
    print("最大:", bst.find_max().key)           # 80
    print("高度:", bst.height())                 # 3
    print("节点数:", bst.count_nodes())          # 7
    print("叶子数:", bst.count_leaves())         # 4

    print("查找 40:", bst.search(40))            # Node(40)
    print("删除 30:", bst.delete(30))            # True
    print("中序 after delete 30:", bst.to_sorted_list())  # [20,40,50,60,70,80]

    print("删除不存在 999:", bst.delete(999))    # False
    bst.clear()
    print("清空后 is_empty:", bst.is_empty())    # True

```









------

## 1) AVL 树（高度平衡：每结点左右子树高度差 ≤ 1）

```python
# avl_tree.py
from typing import Optional, Any, Generator

class AVLNode:
    def __init__(self, key: Any):
        self.key = key
        self.left: Optional['AVLNode'] = None
        self.right: Optional['AVLNode'] = None
        self.height: int = 1

    def __repr__(self):
        return f"AVLNode({self.key})"

class AVLTree:
    def __init__(self):
        self.root: Optional[AVLNode] = None

    # Utility
    def _height(self, node: Optional[AVLNode]) -> int:
        return node.height if node else 0

    def _update_height(self, node: AVLNode) -> None:
        node.height = 1 + max(self._height(node.left), self._height(node.right))

    def _balance_factor(self, node: AVLNode) -> int:
        return self._height(node.left) - self._height(node.right)

    # Rotations
    def _rotate_right(self, y: AVLNode) -> AVLNode:
        x = y.left
        assert x is not None
        T2 = x.right
        x.right = y
        y.left = T2
        self._update_height(y)
        self._update_height(x)
        return x

    def _rotate_left(self, x: AVLNode) -> AVLNode:
        y = x.right
        assert y is not None
        T2 = y.left
        y.left = x
        x.right = T2
        self._update_height(x)
        self._update_height(y)
        return y

    # Insert
    def insert(self, key: Any) -> None:
        self.root = self._insert(self.root, key)

    def _insert(self, node: Optional[AVLNode], key: Any) -> AVLNode:
        if node is None:
            return AVLNode(key)
        if key < node.key:
            node.left = self._insert(node.left, key)
        elif key > node.key:
            node.right = self._insert(node.right, key)
        else:
            return node  # duplicate: ignore
        self._update_height(node)
        balance = self._balance_factor(node)

        # LL
        if balance > 1 and key < node.left.key:
            return self._rotate_right(node)
        # RR
        if balance < -1 and key > node.right.key:
            return self._rotate_left(node)
        # LR
        if balance > 1 and key > node.left.key:
            node.left = self._rotate_left(node.left)
            return self._rotate_right(node)
        # RL
        if balance < -1 and key < node.right.key:
            node.right = self._rotate_right(node.right)
            return self._rotate_left(node)

        return node

    # Search
    def search(self, key: Any) -> Optional[AVLNode]:
        cur = self.root
        while cur:
            if key == cur.key:
                return cur
            cur = cur.left if key < cur.key else cur.right
        return None

    # Min/Max
    def find_min(self, node: Optional[AVLNode]=None) -> Optional[AVLNode]:
        cur = node or self.root
        if cur is None: return None
        while cur.left:
            cur = cur.left
        return cur

    def find_max(self, node: Optional[AVLNode]=None) -> Optional[AVLNode]:
        cur = node or self.root
        if cur is None: return None
        while cur.right:
            cur = cur.right
        return cur

    # Delete
    def delete(self, key: Any) -> None:
        self.root = self._delete(self.root, key)

    def _delete(self, node: Optional[AVLNode], key: Any) -> Optional[AVLNode]:
        if node is None:
            return None
        if key < node.key:
            node.left = self._delete(node.left, key)
        elif key > node.key:
            node.right = self._delete(node.right, key)
        else:
            # found
            if node.left is None:
                return node.right
            elif node.right is None:
                return node.left
            else:
                succ = self.find_min(node.right)
                assert succ is not None
                node.key = succ.key
                node.right = self._delete(node.right, succ.key)
        # update and rebalance
        self._update_height(node)
        balance = self._balance_factor(node)
        # LL
        if balance > 1 and self._balance_factor(node.left) >= 0:
            return self._rotate_right(node)
        # LR
        if balance > 1 and self._balance_factor(node.left) < 0:
            node.left = self._rotate_left(node.left)
            return self._rotate_right(node)
        # RR
        if balance < -1 and self._balance_factor(node.right) <= 0:
            return self._rotate_left(node)
        # RL
        if balance < -1 and self._balance_factor(node.right) > 0:
            node.right = self._rotate_right(node.right)
            return self._rotate_left(node)
        return node

    # Traversals
    def inorder(self) -> Generator[Any, None, None]:
        def _in(n):
            if not n: return
            yield from _in(n.left)
            yield n.key
            yield from _in(n.right)
        yield from _in(self.root)

# Example usage
if __name__ == "__main__":
    a = AVLTree()
    for v in [20, 4, 15, 70, 50, 100, 80]:
        a.insert(v)
    print("AVL inorder:", list(a.inorder()))
    a.delete(70)
    print("After delete 70:", list(a.inorder()))
```

------

## 2) Treap（随机化平衡：BST + heap（优先级））

Treap 的思想简单且实现较短：每个节点有随机 priority，满足 BST 的键序和 heap 的优先级（priority 较小/大看实现）。插入后通过旋转恢复 heap 性质；删除也通过旋转下沉再删除叶子，比较直观。

```python
# treap.py
import random
from typing import Optional, Any, Generator

class TreapNode:
    def __init__(self, key: Any, priority: Optional[int]=None):
        self.key = key
        self.priority = priority if priority is not None else random.randrange(1 << 30)
        self.left: Optional['TreapNode'] = None
        self.right: Optional['TreapNode'] = None

    def __repr__(self):
        return f"TreapNode({self.key}, p={self.priority})"

class Treap:
    def __init__(self):
        self.root: Optional[TreapNode] = None

    # rotations
    def _rotate_right(self, y: TreapNode) -> TreapNode:
        x = y.left
        assert x is not None
        y.left = x.right
        x.right = y
        return x

    def _rotate_left(self, x: TreapNode) -> TreapNode:
        y = x.right
        assert y is not None
        x.right = y.left
        y.left = x
        return y

    # insert
    def insert(self, key: Any) -> None:
        self.root = self._insert(self.root, key)

    def _insert(self, node: Optional[TreapNode], key: Any) -> TreapNode:
        if node is None:
            return TreapNode(key)
        if key < node.key:
            node.left = self._insert(node.left, key)
            if node.left.priority < node.priority:
                node = self._rotate_right(node)
        elif key > node.key:
            node.right = self._insert(node.right, key)
            if node.right.priority < node.priority:
                node = self._rotate_left(node)
        else:
            pass  # duplicate ignore
        return node

    # search
    def search(self, key: Any) -> Optional[TreapNode]:
        cur = self.root
        while cur:
            if key == cur.key:
                return cur
            cur = cur.left if key < cur.key else cur.right
        return None

    # delete
    def delete(self, key: Any) -> None:
        self.root = self._delete(self.root, key)

    def _delete(self, node: Optional[TreapNode], key: Any) -> Optional[TreapNode]:
        if node is None:
            return None
        if key < node.key:
            node.left = self._delete(node.left, key)
        elif key > node.key:
            node.right = self._delete(node.right, key)
        else:
            # node to remove: rotate it down until leaf
            if node.left is None and node.right is None:
                return None
            elif node.left is None:
                node = self._rotate_left(node)
                node.left = self._delete(node.left, key)
            elif node.right is None:
                node = self._rotate_right(node)
                node.right = self._delete(node.right, key)
            else:
                # rotate toward the child with smaller priority
                if node.left.priority < node.right.priority:
                    node = self._rotate_right(node)
                    node.right = self._delete(node.right, key)
                else:
                    node = self._rotate_left(node)
                    node.left = self._delete(node.left, key)
        return node

    # traversals
    def inorder(self) -> Generator[Any, None, None]:
        def _in(n):
            if not n: return
            yield from _in(n.left)
            yield n.key
            yield from _in(n.right)
        yield from _in(self.root)

# Example usage
if __name__ == "__main__":
    t = Treap()
    for v in [50, 30, 70, 20, 40, 60, 80]:
        t.insert(v)
    print("Treap inorder:", list(t.inorder()))
    t.delete(30)
    print("After delete 30:", list(t.inorder()))
```

------

## 3) 红黑树（Red-Black Tree, RBTree）

红黑树实现最复杂——插入涉及颜色与旋转，删除更是繁复。下面提供一个**完整的红黑树实现**（含插入、删除、搜索、遍历）。实现遵循 CLRS 风格（`color` 字段： 'red' / 'black'），并使用哨兵 `NIL` 节点来简化边界条件。

> 注意：红黑树删除逻辑繁琐，但下面实现是完整的、可运行的；若你只需要“插入+查找+遍历”，也可以只用那部分。

```python
# rbtree.py
from typing import Optional, Any, Generator

class RBNode:
    def __init__(self, key: Any, color: str='red', left: Optional['RBNode']=None, right: Optional['RBNode']=None, parent: Optional['RBNode']=None):
        self.key = key
        self.color = color  # 'red' or 'black'
        self.left = left
        self.right = right
        self.parent = parent

    def __repr__(self):
        return f"RBNode({self.key},{self.color})"

class RedBlackTree:
    def __init__(self):
        # sentinel NIL node
        self.NIL = RBNode(key=None, color='black')
        self.NIL.left = self.NIL.right = self.NIL.parent = self.NIL
        self.root: RBNode = self.NIL

    # Left rotate
    def _left_rotate(self, x: RBNode) -> None:
        y = x.right
        assert y is not self.NIL
        x.right = y.left
        if y.left is not self.NIL:
            y.left.parent = x
        y.parent = x.parent
        if x.parent is self.NIL:
            self.root = y
        elif x is x.parent.left:
            x.parent.left = y
        else:
            x.parent.right = y
        y.left = x
        x.parent = y

    # Right rotate
    def _right_rotate(self, y: RBNode) -> None:
        x = y.left
        assert x is not self.NIL
        y.left = x.right
        if x.right is not self.NIL:
            x.right.parent = y
        x.parent = y.parent
        if y.parent is self.NIL:
            self.root = x
        elif y is y.parent.right:
            y.parent.right = x
        else:
            y.parent.left = x
        x.right = y
        y.parent = x

    # Insert
    def insert(self, key: Any) -> None:
        node = RBNode(key=key, color='red', left=self.NIL, right=self.NIL, parent=self.NIL)
        y = self.NIL
        x = self.root
        while x is not self.NIL:
            y = x
            x = x.left if node.key < x.key else x.right if node.key > x.key else None
            if x is None:
                # duplicate key: ignore
                return
        node.parent = y
        if y is self.NIL:
            self.root = node
        elif node.key < y.key:
            y.left = node
        else:
            y.right = node
        node.left = self.NIL
        node.right = self.NIL
        node.color = 'red'
        self._insert_fixup(node)

    def _insert_fixup(self, z: RBNode) -> None:
        while z.parent.color == 'red':
            if z.parent is z.parent.parent.left:
                y = z.parent.parent.right
                if y.color == 'red':
                    # case 1
                    z.parent.color = 'black'
                    y.color = 'black'
                    z.parent.parent.color = 'red'
                    z = z.parent.parent
                else:
                    if z is z.parent.right:
                        # case 2
                        z = z.parent
                        self._left_rotate(z)
                    # case 3
                    z.parent.color = 'black'
                    z.parent.parent.color = 'red'
                    self._right_rotate(z.parent.parent)
            else:
                y = z.parent.parent.left
                if y.color == 'red':
                    z.parent.color = 'black'
                    y.color = 'black'
                    z.parent.parent.color = 'red'
                    z = z.parent.parent
                else:
                    if z is z.parent.left:
                        z = z.parent
                        self._right_rotate(z)
                    z.parent.color = 'black'
                    z.parent.parent.color = 'red'
                    self._left_rotate(z.parent.parent)
        self.root.color = 'black'

    # Transplant (helper for delete)
    def _transplant(self, u: RBNode, v: RBNode) -> None:
        if u.parent is self.NIL:
            self.root = v
        elif u is u.parent.left:
            u.parent.left = v
        else:
            u.parent.right = v
        v.parent = u.parent

    # Minimum from node
    def _minimum(self, x: RBNode) -> RBNode:
        while x.left is not self.NIL:
            x = x.left
        return x

    # Delete
    def delete(self, key: Any) -> bool:
        z = self._search_node(self.root, key)
        if z is self.NIL:
            return False
        y = z
        y_original_color = y.color
        if z.left is self.NIL:
            x = z.right
            self._transplant(z, z.right)
        elif z.right is self.NIL:
            x = z.left
            self._transplant(z, z.left)
        else:
            y = self._minimum(z.right)
            y_original_color = y.color
            x = y.right
            if y.parent is z:
                x.parent = y
            else:
                self._transplant(y, y.right)
                y.right = z.right
                y.right.parent = y
            self._transplant(z, y)
            y.left = z.left
            y.left.parent = y
            y.color = z.color
        if y_original_color == 'black':
            self._delete_fixup(x)
        return True

    def _delete_fixup(self, x: RBNode) -> None:
        while x is not self.root and x.color == 'black':
            if x is x.parent.left:
                w = x.parent.right
                if w.color == 'red':
                    w.color = 'black'
                    x.parent.color = 'red'
                    self._left_rotate(x.parent)
                    w = x.parent.right
                if w.left.color == 'black' and w.right.color == 'black':
                    w.color = 'red'
                    x = x.parent
                else:
                    if w.right.color == 'black':
                        w.left.color = 'black'
                        w.color = 'red'
                        self._right_rotate(w)
                        w = x.parent.right
                    w.color = x.parent.color
                    x.parent.color = 'black'
                    w.right.color = 'black'
                    self._left_rotate(x.parent)
                    x = self.root
            else:
                w = x.parent.left
                if w.color == 'red':
                    w.color = 'black'
                    x.parent.color = 'red'
                    self._right_rotate(x.parent)
                    w = x.parent.left
                if w.right.color == 'black' and w.left.color == 'black':
                    w.color = 'red'
                    x = x.parent
                else:
                    if w.left.color == 'black':
                        w.right.color = 'black'
                        w.color = 'red'
                        self._left_rotate(w)
                        w = x.parent.left
                    w.color = x.parent.color
                    x.parent.color = 'black'
                    w.left.color = 'black'
                    self._right_rotate(x.parent)
                    x = self.root
        x.color = 'black'

    # Search
    def _search_node(self, node: RBNode, key: Any) -> RBNode:
        while node is not self.NIL:
            if key == node.key:
                return node
            node = node.left if key < node.key else node.right
        return self.NIL

    def search(self, key: Any) -> Optional[RBNode]:
        n = self._search_node(self.root, key)
        return None if n is self.NIL else n

    # Traversal (inorder)
    def inorder(self) -> Generator[Any, None, None]:
        def _in(n):
            if n is self.NIL:
                return
            yield from _in(n.left)
            yield n.key
            yield from _in(n.right)
        yield from _in(self.root)

# Example usage
if __name__ == "__main__":
    r = RedBlackTree()
    for v in [41, 38, 31, 12, 19, 8]:
        r.insert(v)
    print("RB inorder:", list(r.inorder()))
    r.delete(38)
    print("After delete 38:", list(r.inorder()))
```

------

## 小结与建议

- **AVL**：严格高度平衡，查找速度稳定且常比 RB 树少一次旋转，但插入/删除时旋转调整频率可能更高，适合读多写少的场景。
- **Treap**：实现最简单、代码短、小概率退化且平均复杂度优秀；由于使用随机优先级，通常适合需要概率性保证的场景。
- **红黑树**：工业界常用（例如 Java 的 TreeMap/TreeSet、Linux 内核、很多标准库实现），删除/插入平衡性好，保证最坏情形下 O(log n)。

